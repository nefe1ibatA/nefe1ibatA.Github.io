{"meta":{"title":"nefe1ibatA's blog","subtitle":"","description":"","author":"nefelibatA","url":"https://nefe1ibatA.github.io","root":"/"},"pages":[{"title":"about","date":"2021-11-27T16:21:05.000Z","updated":"2021-11-27T16:25:44.862Z","comments":true,"path":"about/index.html","permalink":"https://nefe1ibata.github.io/about/index.html","excerpt":"","text":"这里只有一句有用的话：比笨是读来过倒。"}],"posts":[{"title":"A Graphical and Attentional Framework for Dual-Target Cross-Domain Recommendation","slug":"A-Graphical-and-Attentional-Framework-for-Dual-Target-Cross-Domain-Recommendation","date":"2021-11-27T10:11:52.000Z","updated":"2021-11-27T13:56:52.914Z","comments":true,"path":"2021/11/27/A-Graphical-and-Attentional-Framework-for-Dual-Target-Cross-Domain-Recommendation/","link":"","permalink":"https://nefe1ibata.github.io/2021/11/27/A-Graphical-and-Attentional-Framework-for-Dual-Target-Cross-Domain-Recommendation/","excerpt":"","text":"Abstract传统的单目标跨域推荐仅仅只能够通过使用源域的丰富数据来帮助目标域提升推荐准确性。而本文关注的重点是如何同时提升两个域的推荐准确性，即如何进行dual-target CDR。该问题的难点在于： 如何生成更加有效的user embeddings和item embeddings。 如何能够更有效地优化两个域中的embeddings。 本文对于此问题提出了一种名为GA-DTCDR的模型。 Introduction对于传统的single-target CDR来说，是通过将Richer Domain的数据学习到的结果用于Sparser Domain。那么一个主观的想法是，能不能仅仅加上一个传播的方向，”Sparser2Richer”，就能够模型在两个域的推荐效果都得到提升呢？但实际上这并不可行，因为Richer的模型通常效果好于Sparser的模型，因此直接这样做更大的可能是Richer Domain的效果还会变差。因此需要寻求更加有效的方法，来提高两个域的输入的丰富性，这个方法就是Graphical and Attentional framework for Dual-Target Cross-Domain Recommendation。 The Proposed Model Input Layer文章同时考虑了显式反馈和其它信息，并将其分为两类，一类是rating information，另一类是content information，可以理解为数值类和文本类。 Graph Embedding LayerDocument Embedding首先为了生成用户和商品之间的异构图，需要将用户和商品之间相似度计算出来。我们收集每个节点的所有的文本类信息，通过Doc2vec得到text vector矩阵。 Graph Construction 通过User和Item之间的打分交互来连接User和Item，边的权重采用归一化评分$$R/max(R)$$进行赋值 对于User和User或是Item和Item之间，通过text vector的相似度进行选择性地生成边。 Output将异构图输入Node2Vec等graph embedding model，可以得到user embedding matrix和item embedding matrix。 Feature Combination Layer使用element-wise attention将两个域中的User特征进行交互。 Training for Neural Network Layers and Output Layer对于任意一组user和item，计算二者之间的相似度，就是本文对于其交互结果的预测值。而交互结果的真值在有评分的情况下就是评分，如果没有评分，进行负采样，即设置一部分空值为0。 损失函数采用归一化交叉熵：$$\\ell (y,\\hat y)=\\frac{y}{max(R)}\\log \\hat y+(1-\\frac{y}{max(R)})\\log (1-\\hat y)$$ Experiments该模型在多个数据集上取得了较好的结果。","categories":[{"name":"paper reading","slug":"paper-reading","permalink":"https://nefe1ibata.github.io/categories/paper-reading/"}],"tags":[]},{"title":"配置个人blog","slug":"blog-configure","date":"2021-11-26T19:35:14.211Z","updated":"2021-11-27T11:15:32.299Z","comments":true,"path":"2021/11/27/blog-configure/","link":"","permalink":"https://nefe1ibata.github.io/2021/11/27/blog-configure/","excerpt":"","text":"本博客采用的是 Github Pages + hexo 进行配置。Github Pages 的创建方法网上已经有很多博客写了，因此这里就不再进行说明，默认已经创建好了github repository。本教程以Mac OS为例。 配置Hexo文件夹安装 Node / Npm此处需要注意，一定要指定node版本，如果版本太新后面会出现问题。此处指定版本为12。 12$ brew update$ brew install node@12 注意安装之后的信息，会提示如何将其加入PATH。安装完毕后可以通过node -v进行版本查看。 安装 Hexo12345$ npm install hexo -g$ hexo init blog$ cd blog$ npm install$ hexo s 这时候博客已经在本地生成了，可以通过访问http://localhost:4000查看效果。 Hexo 基本操作 hexo g 生成public文件夹，就是在github仓库上面可以被访问的文件夹。 hexo d 将网站推送到远程。 hexo clean 删除文件夹。 hexo s 在本地查看网站效果。 更改配置文件首先在根目录找到_config.yml，进行如下修改： language: zh-CN / en (中文 / 英文) url: https://username.github.io/project theme: 选择主题 deploy: type: git repository: (https / ssh) branch: master 将配置推送到Github1$ hexo d","categories":[{"name":"Other things","slug":"Other-things","permalink":"https://nefe1ibata.github.io/categories/Other-things/"}],"tags":[]}],"categories":[{"name":"paper reading","slug":"paper-reading","permalink":"https://nefe1ibata.github.io/categories/paper-reading/"},{"name":"Other things","slug":"Other-things","permalink":"https://nefe1ibata.github.io/categories/Other-things/"}],"tags":[]}